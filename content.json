{"pages":[{"title":"About Me","text":"Education Shenzhen College of International Education, Class of 2022 Programming SCIErs Miniapp Indie developer VATSIM P.R.C. Division Assistant Webmaster (VATPRC8A) Avation VATSIM P1 Pilot, C1 Controller","link":"/about/index.html"}],"posts":[{"title":"Fastai Learning Note","text":"Fastai Course V3 Lesson 1Always includes these lines123456%reload_ext autoreload%autoreload 2%matplotlib inlinefrom fastai.vision import *from fastai.metrics import error_ratebs = 64 Get Datasets with Fast AI12path = untar_data(URLs.PETS)path.ls() Setting up DataBunch1data = ImageDataBunch.from_name_re(path_img, fnames, pat, ds_tfms=get_transforms(), size=224, bs=bs).normalize(imagenet_stats) In Fast AI, almost every data is going to be a databunch. We use size = 224 as almost models are training in 7 * 7. TrainingWhat’s in?1data.show_batch(rows=3, figsize=(7,6)) Get the model1learn = cnn_learner(data, models.resnet34, metrics=error_rate) Resnet 34: A great picture analyzing model, also have resnet50 (34 -&gt; 34 layers) Train it12learn.fit_one_cycle(10)learn.save('stage-1') # Always save your file after training What’s out?123456interp = ClassificationInterpretation.from_learner(learn)interp.plot_top_losses(9, figsize=(15,11)) # Get pics that have top losses# Which type is most confused?interp.plot_confusion_matrix(figsize=(12,12), dpi=60)interp.most_confused(min_val=2) More TrainingUnfreezing and train all the layerBasicly, the default model is only training the top layers, but if we unfreez it we can train everylayer equaly However, we need to find the LR first 12learn.lr_find()learn.recorder.plot() We want to find the down slope 12learn.unfreeze()learn.fit_one_cycle(10, max_lr=slice(1e-4,1e-2)) Then our error_rate reduced a lot! (Hopefully) Lesson 2Things that can go wrongLR too highvalid_loss &gt; 1 Cannot undo, just re-creat the model LR too smalllearning really slow, train_loss &gt; valid_loss Too few epochstrain_loss &gt; valid_loss Too many epochsOverfitting Error rate decreasing and then start to increase SGDTensor - Regular shape arrayRank - how many ‘axis’ do we have (1D, 2D, 3D) 12345tensor(3., 2.) # a rank1 tensortorch.ones(n, 2) # n x 2 (n rows and 2 cols), fill with 1s. So it's a rank2 tensorimport matplotlib as pltplt.scatter(...) # Matplotlib also accept tensor Vocab Learning Rate - The rate of learning (The thing we times our gradient every time) Epoch - One complete run of our datas Minibatch - A random set of our data Model / Architecture - A mathematical function that we need to find the parameters Parameters - Coefficient, the number that we are updating in training","link":"/2020/Fastai-learning-note/"},{"title":"Cryptography Note 1 - Intro","text":"Coursera Cryptography I by Stanford University What is CryptographyCore Secret key establishment Secure communication More Digital signature Different signature for differnet documents Anonymous communication Mix net (Proxies) Bidirectional Anonymous digital cash ProtocolsSecure multi-party computationAnything that can done with trusted auth. can also done without auth. (The blue line is the protocols) Crypto magic Privately outsourcing computation The server know nothing about what they’re computing Zero knowledge Alice can prove that she knows the factor of N, but Bob learn nothing about the solution A rigorous science3 steps Precisely specify threat model Propose a construction Prove that breaking construction under threat mode will solve an underlying hard problem HistorySymmetric CipherBoth encrypter and decrypter use same key Substitution Cipher Key: a -&gt; c, b -&gt; z, c -&gt; b … What is the key space? 26! (26 fractional) How to break it? Use frequency of English letters (e.g. E is the most common letter) ‘e’ 12.7%, ‘t’ 9.1%, ‘a’ 8.1% … Use frequency of pairs of letters ‘he’, ‘an’, ‘in’, ‘th’ … Caesar Cipher (No key, not really a cipher) a -&gt; d, b -&gt; e, c -&gt; f … Vigener Cipher (16th century, Rome) How to break it? Assume we know the length of key first The most common letter in the given position of the group (e.g. the first leter of a group) Then use the freq. of english letters to find the key Rotor Machines (1870-1943) Substitution Cipher but change every letter (Rotating) If we click C 3 times, we get SKE Break? English freq Most famous the Enigma routers that routating at different rate Data Encryption Standard (1974) DES key = $2^56$, 64bits Unsafe today Today: AES (128bits) (2001), Sala20 (2008) Quick Discrete ProbabilityU: finite set$$U = {0,1}^n$$ e.g. $${0,1}^2 = {00,01,10,11}$$ P: Probability distribution over U is a function P:U -&gt; [0,1] $$\\sum_{x \\in U}{P(x)} = 1$$ Uniform distribution: $$\\text{For all }x\\in U: P(x) = 1 / |{U}|$$ Point distribution: $$P(x_0) = 1, \\forall x \\ne x_0 : P(x) = 0$$ Events:$$\\text{For a set } A \\subseteq U: P$$","link":"/2020/Cryptography-Note1/"},{"title":"Cryptography Note 2 - Stream Ciphers","text":"Coursera Cryptography I by Stanford University Cipher A cipher defined over K (key space), M (possible message), e (posible cipher text) Cipher is a pair of (E, D) (Encrypt and Decrypt algorithm) E: K x M -&gt; eD: K x e -&gt; M D(k, E(k, m)) = m E is often randomizedD is often deterministic The One Time PadVernam, 1917 First example of a ‘secure’ Cipher $$M = E = {0, 1}^n$$ Also need a key $$key = (\\text{rand bit string as long as the msg.})$$ $$E(k, m) = k \\oplus m , D(k, c) = k \\oplus c$$ However, you can also get the key $$\\text{key} = m \\oplus c$$ Also, the key is as long as the plaintext (Really long) It’s perfect secure! ! SecrecyBasic idea: Cypher text should reveal no ‘info’ about plain text Perfect SecrecyPr(E(k, m0)) = c = Pr(E(k, m1)) = cGiven a cypher text, can’t tell if msg is m0 or m1 (For all m0, m1) One Time Pad has perfect secrecy$$\\forall m, c: Pr[E(k,m)=c] = \\frac{\\text{num of keys k in K such that }E(k,m) = c}{\\text{total num of key}}$$Since num of keys k in K such that E(k,m) = c is actually 1, OTP has perfect secrecy So, we can conclude that OTP do not have Cypher text only attack!!!(but other attacks possible) Also, Perfect secrecy =&gt; |K| ≧ |M| (Num of key ≧ Num of msg) However, OTP is hard to use in practice because the key is too long Attact 1: Two time pad$$C_1 \\leftarrow m_1 \\oplus PRG(K) \\text{ And } C_2 \\leftarrow m_2 \\oplus PRG(K)$$ Eavesdropper does $$C_1 \\oplus C_2 \\rightarrow m_1 \\oplus m_2$$Enough redundancy in English and ASCII to get plain text! Real worldProject Venona Rusian, 1941-1946 Key generated by throwing dice Find it’s boring to throwing dice so reused MS-PPTP Windows NT Client &lt;-&gt; Server Messages from client and server use same key YOU NEED DIFFERENT KEYS FOR C -&gt; S and S -&gt; C 802.11b WEP A very bad protocol PRG(IV || k) IV is a 24bit, it inincrement by 1 evertime k is a long term key IV and ciphetext is send together Problem Repeated IV after 16M frames On some 802.11 cards IV resets to 0 after power cycle After 10^6 fram,you can recover the long term key k (Since the changing part IV is relative short) Solution PRG(k) first, use part of the result for the key of fram Attact 2: No integrityThe attacker XOR another thing to the key User: E(m) = m ⨁ kAttacker: (m ⨁ k) ⨁ pUser: D() = m ⨁ p One Time Pad is malleable (Easy to edit the cipher text) Stream CiphersMaking OTP Practical with Pseudo Random Generators Encrypt $$E(k, m): m \\oplus G(k)$$Decrypt $$D(k, c): c \\oplus G(k)$$ SecurityCannot have perfect secrecy!! (Key shorter than msg) PRGA function G take keys to make longer key(a pseudo random sequence) $$G:{0, 1}^s \\rightarrow {0, 1}^n , n &gt; s$$ The PRG mast be unpredictableIf it’s not, the hacker can use the encrypted text and known prefix (e.g. From in SMTP) and XOR them to get the pseudo random sequence It is predictable when: Exist an “eff” algorithm A, $$Pr[A(G(k)|{1,…,i}) = G(k)|{i+1}] \\ge 1/2 +\\varepsilon$$ For some “Non-negligible” ε Non-negligibleHave different value in different area In practice, ε is a scalar and $$\\text{non-neg: }\\varepsilon \\ge 1/2^{30}$$ In theory, ε is a function $$\\text{non-neg: }\\exists d: \\varepsilon(\\lambda) \\ge 1/\\lambda^d \\text{ inf. often}$$ (ε &gt;= 1/polu, for many λ) Weak RPGsLinear congruential generatorParameter a, b, pr[0] = seed r[i] &lt;- a · r[i-1] + b output few bits of r[i] i++ (And back to 1) Don’t use any random from glibc Random Real-World Stream CiphersRC4(Do not use in new system)128 bits seed -&gt; 2048 bits -⟲-&gt; 1 byte per roundUsed in HTTPS and WEP Weakness Bias in initial output Pr[2nd byte = 0] = 2/256 Prob. of (0,0) is 1/256² + 1/256³ Related key attacksCSS (Broken) Used on CD/DVD Linear feedback shift register (LFSR): Shift the right evey clock cycle, choose several bit and XOR them, use it as the first bit of the result How it workSeed: 5 bytes (40 bits) 1||First 2 bytes of the key(key) =&gt; 17 bit LFSR – Run for 8 cycle –&gt;1||Last 3 bytes of the key(key) =&gt; 25 bit LFSR – Run for 8 cycle –&gt; –&gt; Plus together and mod 256 -&gt; Output 1 byte per round Break it2¹⁷ timesAs we know the prefix(20 byte) of the plaintex (Because it’s a DVD)Try all 2¹⁷ possible value of the first LFSR, then we will see the 25bit LFSR eStream (2008)PRG: ${0,1}^s \\times R -&gt; {0,1}^n$R is a nonce, which is a non-repeating value for a given key$$E(k,m;r) = m \\oplus PRG(k, r)$$ So you can repeat the use of key as the R is changing Salsa 20Sala20: ${0,1}^{128} \\times {0,1}^{64} -&gt; {0,1}^n$Salsa 20(k; r) := H(k, (r, 0)) || H(k, (r, 1)) || …","link":"/2020/Cryptography-Note2/"}],"tags":[{"name":"Notes","slug":"Notes","link":"/tags/Notes/"},{"name":"Machine Learning","slug":"Machine-Learning","link":"/tags/Machine-Learning/"}],"categories":[{"name":"CS Learning","slug":"CS-Learning","link":"/categories/CS-Learning/"},{"name":"Math Learning","slug":"Math-Learning","link":"/categories/Math-Learning/"}]}